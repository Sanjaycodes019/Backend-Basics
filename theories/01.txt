// introduction to client server and request handling

Client -> Sends requet (browser, mobile app)
Server -> Processes request, sends response (Node.js backend)

Request-Respone cycle
1. client sends http request
2. server processes request (using code, database etc)
3. server sends http response backend

Client(browser) -> http request -> server(node.js)
server -> http respones -> Client

Key Points
-> server listens on port like 3000, 8080
-> uses http methods
    GET - retrieve data
    Post - Send data
    Put - update data
    Delete - remove data

Sample Code 

 const http = require('http);

 const server = http.createServer((req, res)=>{
    res.writeHead(200, {'content-type':'text/plain'});
    res.end('hello, this is my first node.js server');
 });

 serve.listen(3000, ()=>{
    console.log('server running on the port http://localhost:3000')
 });


how it works? 
http.createServer() -> creates server
callback (req, res) -> handles incoming request & response
server.listen(3000) -> server listens on port 3000


trick 
http.createServer((req, res)={...})
res.writeHead(statuscode, headers)
res.end('response)


flow
request -> server -> process -> response



_________________________________________________________________________


Request-Respose LifeCycle

whenever we type url in browser
1. DNS Lookup -> domain converts into ip
2. Client sends http Request -> to server ip on port
3. server processes -> using backend logic (node.js code, database, etc)
4. server sends http response -> back to client


Key http components

-> Request Object (req)
req.method-> GET/POST/PUT/Delete
req.url-> URL path requested
req.header-> MetaData(user-agent, content-type)

-> Response Object (res)
res.writeHead(statuscode, headers)
res.end(data)



// types of server

Static Server -> only serves html, css, js (no processing)
Dynamic Server -> Runs code, queries DB, returns dynamic content

// trick and syntax
http.createServer((req, res)=>{
    res.writeHead(200, {'content-type:'text/plain'})
    res.end('response here')
}).listen(3000)


Node introduction
- javascript runtime environment built on chrome's v8 engine
- run js outside the browser (on the server)

Why is it popular? 
- lightweight and fast (uses eventdriven, non-blocking IO)
- uses javascript everywhere (frontend&backend)
- huge ecosystem (npm modules)

Advantages of NodeJS
- Single programming language -> js on both client and server
- Async and Non-Blocking -> handles multiple request efficiently
- cross-platform -> works on windows, mac, linux
- rich package manager (npm)-> thousand of ready-to-use modules
- good for real-time apps (chat, streaming, etc)

Disadvantages of NodeJS
- CPU intensive tasks (like image processing) can block event Loop 
- Callback hell in older code (fixed by promies and async/await)
- Not suitable for Heavy Multithreaded applications

Working of NodeJS
- Single Threaded Event Loop -> Handles request asynchronously
- Non - Blocking I/O -> Worker Thread (if need) -> Response sent

Core Modules in NodeJS
http -> create server, handle request and response
fs -> file system operations
path -> handles file path
os -> os-related info
events -> Event handling

modules are the reusabe block of code that can be implemented into other files
nodejs has 
core modules - http, fs, path
local modules - custom files
thirdparty modules - installed via npm and express



_code of http module_

const http = require('http');

http.createServer((req, res) => {
    console.log('Request URL:', req.url);
    console.log('Request Method:', req.method);

    res.writeHead(200, { 'Content-Type': 'text/plain' });
    res.end('Request Received Successfully!');
}).listen(3000, () => {
    console.log('Server running on http://localhost:3000');
});


- always cleck req.method and req.url for routing
- repose must end with res.end()


Node Package Manager(NPM)
- NPM is a default package manager for nodejs
- install 3rd party packages(modules) from the npm registry
- manages dependencies using package.json

package.json
- file that contains metadata of the project
- project name, version, author 
- scripts 
- dependencies

-> we create package.json by
npm init -y   # -y creates with default values

// installing a dev dependency
   -> npm install nodemon 
   npx nodemon server.js
automatically restarts the server on filechange


// Express js introduction
-> ExpressJS is a minimal and flexible Node.js web application framework
-> makes easy to handle
- routing
- middleware
- http request and responses
- static files

# WHY express? 
-> with core we manually check req.url , req.method
-> express simplifies
- cleaner syntax
- middleware support
- built-in router
- large ecosystem

# creating a basic express server

const express = require('express')
const app = expree();

app.get('/', (req, res)=>{
    res.send('welcome to express');
});

app.listen(3000, () =>{
    console.log('server started and running at port 3000');
})

# express routing
-> express used methods that match http verbs
- app.get(path, callback)
- app.post(path, callback)
- app.put(path, callback)
- app.delete(path, callback)


# handling query and params
// Query parameters: /search?name=John
app.get('/search', (req, res) => {
    res.send(`You searched for: ${req.query.name}`);
});

// URL parameters: /user/10
app.get('/user/:id', (req, res) => {
    res.send(`User ID: ${req.params.id}`);
});

___________________________________________________________________________

Middleware:

function that executes during the request-response cycle
it can :
- modify the req, res objects
- end the response cycle
- pass control to next middleware

Syntax of middleware

app.use((req, res, next)=>{
    do something
    next();
})

Types of Middleware

Application-level -> app.use(...), runs for all request
Route-level -> used for specific routes
Built-in -> express.json(), express.static()
ThirdParty -> morgan, cors, body-parser, etc


const express = require('express');
const app = express();

// Custom middleware
app.use((req, res, next) => {
    console.log(`${req.method} ${req.url}`);
    next();
});

// Route
app.get('/', (req, res) => {
    res.send('Home Page');
});

app.listen(3000, () => {
    console.log('Server running on http://localhost:3000');
});



_____Built-in middleware______________

app.use(express.json())

Tricks to remember middleware
- always end middleware with next()
- it executes in the order it's written
- use express.json() brefore reading req.body

# Request Component Recap
| Component| Accessed via          | Example URL                                 |
| ---------| ----------------------| ------------------------------------------- |
| Params   | `req.params`          | `/user/123` → `req.params.id = 123`         |
| Query    | `req.query`           | `/search?name=abc` → `req.query.name = abc` |
| Body     | `req.body`            | `{ name: "John" }` in POST request          |
| Headers  | `req.headers`         | Custom or default headers                   |
| Method   | `req.method`          | `GET`, `POST`, `PUT`, `DELETE`              |
| URL/Path | `req.url`, `req.path` | `/users/abc`                                |


# Using url params
# URL: /user/101
app.get('/user/:id', (req, res)=>{
    const userID = req.params.id;
    res.send(`user id: ${userID}`);
});



# Using query strings
#  URL: /search?q=nodejs
app.get('/search', (req, res)={
    const keyword = req.query.q;
    res.send(`search result for: ${keyword});
});


# Using request body (POST)
-> requires middleware

app.use(express.json());

app.post('/login', (req, res)=>{
    const{username, password} = req.body;
    res.send(`recieved login for ${username}`);
});


# final trick 
part      tip
params -> always use : in route path
query  -> use req.query.Key
body   -> use express.json() first



# What is REST API? 
REST = Representational state transfer
A REST API uses HTTP method to perform operations on resources(data)

